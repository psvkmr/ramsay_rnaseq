---
title: "ProjectName_Contrast"
author: "Prasanth Sivakumar"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
    toc_depth: 4
    toc_collapsed: FALSE
    toc_float: FALSE
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir = normalizePath('C:/Users/Prasanth/Documents/ramsey/')) 
```

### Input data


```{r libs, message=FALSE, warning=FALSE}
library(PCAtools)
library(DESeq2)
library(tidyverse)
library(vsn)
library(pheatmap)
library(ggrepel)
library(gprofiler2)
```

```{r load_cms}
# load count matrices
load('ramsey_s303_norm_counts_matrix.RData')
load('ramsey_s303_non_zero_counts_matrix.RData')
```

```{r load_md}
# load metadata
md <- read.csv('s303_metadata.csv')
```

```{r ids}
ids <- read.csv('C:/Users/Prasanth/google_drive/guys/resources/biomart_unique_ensembl_genes.csv')
```

```{r modify_md}
# fix metadata names
md$matrix_id <- gsub(' ', '.', md$sample_id)
# re-sort whole md to match matrix variable order
md <- arrange(md, factor(matrix_id, levels = colnames(zcm)))
# convert matrix ids to row names
md <- column_to_rownames(md, 'matrix_id')
# check orders
identical(rownames(md), colnames(zcm))

# edit md 'reactive lymph nodes' to shorten
md$sampleName <- rownames(md)
```

&nbsp;

#### Metadata

```{r study_specific}
# in this analysis, only the 'NAT' samples are going to be used, 
# so both the md and cm will be subsetted for these
smpls <- colnames(zcm)[grep('subset_name', colnames(zcm))]
counts.matrix <- zcm[, smpls]
normalised.counts <- ncm[, smpls]
coldata <- md[smpls, ]

# sample groups
smpl.grps <- list(ctrl = rownames(nat.md[nat.md$sample_group == 'Control', ]), 
                  reac = rownames(nat.md[nat.md$sample_group == 'Reactive_LN', ]))
```

```{r md}
# subset metadata by comparisons
coldata$sample_group <- factor(mds$sample_group, levels = c('Control', 'Reactive_LN'))
levels(coldata$sample_group)
```

The number of samples used in this analysis

```{r nsamples}
length(coldata$sample_id)
```

IDs of the samples used in the analysis

```{r smpls}
coldata$sample_id
```

Number of samples split by contrast group

```{r grps}
table(coldata$sample_group)
```

Metadata file subset provided for the analysis. Not all variables in this file were used in the analysis process.

```{r mdr}
coldata
```

Check ID orders are same in metadata and counts matrix

```{r id_order}
identical(colnames(counts.matrix), rownames(coldata))
```

&nbsp;
&nbsp;

#### Input count matrices

Dimensions of the input counts matrix for analysis: rows (genes) x columns (samples)

```{r zcms}
# cms subset by sample group comparisons
# cms filtered for low counts specifically in comparison subset
counts.matrix <- counts.matrix[rowSums(counts.matrix) > (((dim(counts.matrix)[2])/2)-1), ]
dim(counts.matrix)
```

5x5 subset example of the counts matrix pre-normalisation

```{r cmsub}
counts.matrix[1:5, 1:5]
```

The same 5x5 subset example of the counts matrix post-normalisation for library size and possible tissue discrepancies

```{r ncms}
# normalised subset cms
normalised.counts[rownames(counts.matrix), ][1:5, 1:5]
```



&nbsp;
&nbsp;

#### Outliers

Outline of potential outlier counts in genes for every sample.  Outlier here is defined as a value 3 standard deviations away from the mean count for that gene across the samples. 
Outlier counts: (NULL means no outlier gene counts)

```{r outliers, message=FALSE}
# outlier check
outlierCheck <- function(mat){
  g <- list()
  s <- list()
  for (i in 1:(dim(mat)[1])){
    mean.i <- mean(mat[i, ])
    sd.i <- sd(mat[i, ])
    for (j in mat[i, ]){
      if (j > (mean.i + (3*sd.i)) & sd.i > 1){
        g <- append(g, row.names(mat)[i])
        s <- append(s, colnames(mat)[which(mat[i, ] == j)])
      } else if (j < (mean.i - (3*sd.i)) & sd.i > 1){
        g <- append(g, row.names(mat)[i])
        s <- append(s, colnames(mat)[which(mat[i, ] == j)])
      }
    }
  }
  o <- data.frame('sample' = unlist(s), 'gene' = unlist(g))
  return(o)
}

outliers <- outlierCheck(normalised.counts)
```

```{r outplt}
plotOutliers <- function(outlier){
  df <- as.data.frame(table(outlier$sample))
  if (nrow(df) != 0){ 
    ggplot(df, aes(Var1, Freq)) + 
      geom_col(fill = 'lightsalmon3') +
      labs(x = 'Sample', y = 'Outlier Gene Count') + 
      theme_classic() +
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
  }
}

outliers.plots <- plotOutliers(outliers)

outliers.plots
```

&nbsp;
&nbsp;

### Clustering

&nbsp;

#### PCA

```{r vst}
# stabilise variance across data to make it homoskedastic
var.stable.counts <- varianceStabilizingTransformation(counts.matrix)
# similar to scale(log2(normalised.counts + 1), center = T, scale = T)
```


```{r run_pcas, message=FALSE}
# run pca, remove bottom 10% of variables based on variance
pcas <- pca(var.stable.counts, metadata = coldata, removeVar = 0.1)
```

Principal component analysis is unsupervised, the results do not factor in the sample group to which each sample has been labelled. \n

The analysis produces 'components'. Each component can be used to explain a % of the total variation across the samples counts. 
&nbsp;
&nbsp;

##### Scree plot

How few components the variation in samples be reduced to.

Scree plots show the results of this. Principal component 1 explains the most variation. Also marked is the principal component at which cumulatively 80% of the variation in the dataset can be explained. 

```{r screes, warning=FALSE}
# plot the components eigenvalues as % variance explanation
optimumScree <- function(pca, ttl){
  comp <- which(cumsum(pca$variance) > 80)[1]
  plt <- screeplot(pca,
            components = getComponents(pca, 1:8),
            vline = comp, axisLabSize = 8, 
            title = ttl, gridlines.major = F, gridlines.minor = F, 
            borderWidth = 0.5, xlabAngle = 45, colBar = 'lightsalmon3') +
    geom_label(aes(x = comp, y = 10,
                   label = '80% explained', vjust = -3, hjust = 1, size = 8)) 
  return(plt)
}

optimumScree(pcas, 'Control v Reactive LN')
```

#### Bi-plot

How samples vary relative to each other in the top principal components.

Here are the classic PCA plots showing differences between each sample, labelled by sample group. Each sample group is also highlighted, and sample ID labelled. \


```{r bi_sample, message=FALSE}
# biplot of all samples by PC1 vs PC2, with clouds
bi.plt.smpls <- 
  biplot(pcas, showLoadings = F, colby = 'sample_group', 
                                  encircle = T, widthConnectors = 0.1, 
                                  gridlines.minor = F,  gridlines.major = F,
                                  legendPosition = 'right', legendLabSize = 8,
                                  legendTitleSize = 8, legendIconSize = 4,
                                  axisLabSize = 8, borderWidth = 0.5, xlim = c(-25, 25))

bi.plt.smpls
```


#### Pair-plot

How the samples vary by each of the top 4 PCs compared.

Overview of principal component comparisons across the first 4 components. for each analysis. In each grid, each principal component in compared to every other principal component from PC1-PC4. This can be useful to see if the samples segregate by sample group in components smaller than PC1 and PC2.


```{r paired}
# comparison scatters for PC1-4 on grid
pairs.plt <- 
  pairsplot(pcas, components = getComponents(pcas, 1:4),
                                     triangle = F, colby = 'sample_group',
                                     axisLabSize = 8, 
                                     margingaps = unit(c(0.2, 0.2, 0.2, 0.2), 'cm'), 
                                     borderWidth = 0.5)
pairs.plt
```

The sample-based principal component information outlined above can be seen in table format. In this table, the value of each sample in each principal component is displayed. 

```{r rotated}  
# sample contribution to each PC
rotateds <- pcas$rotated[1:4]
rotateds
```

&nbsp;
&nbsp;

#### Loadings

Which genes have the most influence in variation explained by each prinicipal component.

Plot of loadings for each principal component. Each gene in the matrix has a different level of influence on the variation in the principal component as a whole. Genes with the largest component loading (here in absolute values) can be thought of as the genes driving the differences in the component. 

```{r loadings, message=FALSE}
# plot individual contribution of genes with largest loadings
loadings.plt <- 
  plotloadings(pcas, components = getComponents(pcas, 1:4), rangeRetain = 0.001, 
                                        shapeSizeRange = c(2, 10), absolute = T, legendPosition = 'none', 
                                        #legendLabSize = 8, legendIconSize = 4, 
                                        axisLabSize = 8, gridlines.major = F, gridlines.minor = F, hline = NULL, 
                                        borderWidth = 0.5, labSize = 2, labhjust = 0.9, 
                                        col = c('white', 'lightsalmon3'))
loadings.plt
```

#### PC - Variable correlation

Which metadata variables align best with the principal components.

Correlation table for each principal component by variables provided in the metadata (r-squared). A strong correlation betwen principal component and variable suggests that the variable underlies a strong proportion of the variation explained by that principal component. If a variable correlates strongly with PC1, then that suggests that the variable has a strong impact on overall variation in the gene counts differences in the counts matrix.

```{r eigcor2, warning=FALSE}
# get pearson r2 values and significane of correlation of PCs with metadata variables
# unnamed columns
eigencorr2.plt <-
  eigencorplot(pcas, getComponents(pcas, 1:4),
                                        metavars = c('sample_group', "rin_2", 
                                                     "a260_280_ndrop"), 
                                        colCorval = 'white', posColKey = 'top', 
                                        plotRsquared = T, corFUN = 'pearson', corUSE = 'pairwise.complete.obs', 
                                        col = c('navajowhite2', 'indianred1', 'indianred2', 'firebrick1'), corMultipleTestCorrection = 'BH')
eigencorr2.plt
```

Design formula 

```{r des}
design.formula <- '~sample_group'
```

```{r dds, message=FALSE}
deseq.dataset <- DESeqDataSetFromMatrix(
  countData = counts.matrix,
  colData = coldata, 
  design = design.formula)
```

```{r filt_dds, message=FALSE}
deseq.dataset.filtered <- deseq.dataset[rowSums(counts(deseq.dataset)) >= 3]
```

```{r deseq, message=FALSE}
deseq.analysis <- DESeq(deseq.dataset.filtered)
```

&nbsp;
&nbsp;

#### Heatmap of abundant genes

Heatmap of normalised expression levels of the top 10 most abundant genes in the dataset by sample. 
On top is the result of heirarchical clustering by correlation of gene counts, showing how similar sample gene counts are across these abundant genes.

```{r clust}
select <- order(rowMeans(counts(deseq.analysis, normalized=T)),
                  decreasing=T)[1:10]

df <- as.data.frame(colData(deseq.analysis)[, 'sample_group'], row.names = row.names(colData(deseq.analysis))) %>% `names<-`('Group')

pheatmap(assay(normTransform(deseq.analysis))[select,], cluster_rows=F, show_rownames=T, cluster_cols=T, annotation_col = df, scale = 'row', clustering_distance_rows = 'correlation')
```

&nbsp;
&nbsp;

#### Heatmap of all genes

Heatmap of normalised expression levels of all expressed genes in the dataset by sample. 
On top is the result of heirarchical clustering by correlation of gene counts, showing how similar sample gene counts are across all expressed genes.


```{r fh}
gselect <- order(rowMeans(counts(deseq.analysis, normalized=T)),
                  decreasing=T)
df <- as.data.frame(colData(deseq.analysis)[, 'sample_group'], row.names = row.names(colData(deseq.analysis))) %>% `names<-`('Group')
pheatmap(assay(varianceStabilizingTransformation(deseq.analysis))[gselect, ], cluster_rows=F, show_rownames = F, cluster_cols = T, annotation_col = df, scale = 'row')

```

&nbsp;
&nbsp;

#### Heatmap of sample similarity

Heatmap of sample by sample comparison across all expressed gene counts. Clustering based on similarity described by complete euclidean distances.

```{r cor}
vsd <- varianceStabilizingTransformation(deseq.analysis)
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$sample_group, vsd$sample_id, sep="-")
colnames(sampleDistMatrix) <- NULL
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists)
```

&nbsp;
&nbsp;


### Differential gene expression

To analyse the differential expression across all genes in the dataset by the provided design, three steps are required, and all are run combined using a single function in DESeq2.

1. Normalisation
1. Estimated dispersion
1. Statistical analysis

&nbsp;
&nbsp;

#### Differential gene expression results summary

Brief summary of number of significant gene expression changes by up- and downregulation.

```{r res, message=FALSE}
deseq.results <- results(deseq.analysis)
summary(deseq.results, alpha = 0.05)
```

&nbsp;

Example subset of results file columns for top 5 most significantly differentially expressed genes.


```{r results_df}
toDf <- function(res){
  arrange(as.data.frame(res), pvalue) %>% 
    rownames_to_column(var = 'ensembl_gene_id') %>%
    left_join(ids, by = 'ensembl_gene_id') %>%
    mutate(fold_change = 2^log2FoldChange) %>%
    dplyr::select(c('external_gene_name', 'ensembl_gene_id', 'uniprot_gn_id', 
                    'chromosome_name', 'start_position', 'end_position', 
                    'fold_change', 'log2FoldChange', 'pvalue', 'padj'))
}

deseq.dfs <- toDf(deseq.results)

head(deseq.dfs, n = 5)
```

## Additional workflow

Additional steps during the differential gene expression workflow are not essential to obtaining the results, but are highly recommended to ensure the results are valid and the analysis has been performed in optimal settings. They can also provide supplementary information to aid in understanding the expression results and planning downstream analyses.

## Prior QC

Before running the differential gene expression analysis, it is best to perform some quick checks on the counts matrix, to ensure it is suitable for use in the analysis. 

One method is to check the library sizes and make sure the differences in sizes after sequencing are normalised for.

```{r size}
colSums(counts.matrix) %>%
  as.data.frame() %>%
  `colnames<-`('counts') %>%
  rownames_to_column('sample') %>%
  ggplot(aes(sample, counts)) +
  geom_col() +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0)) 
```

As you can see, the libraries have notable differences in total counts, so without normalising these, the differential gene expression will just show differences in library sizes. \
DESeq2 does this for us, as part of the _DESeq_ function. 

To check if the normalisation was successful:

```{r sf}
colSums(counts(deseq.analysis, normalized = T)) %>%
  as.data.frame() %>%
  `colnames<-`('counts') %>%
  rownames_to_column('sample') %>%
  ggplot(aes(sample, counts)) +
  geom_col() +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0))
```

You can see now that the libraries are all broadly the same size.

This normalised counts matrix can then be explored on a gene-by-gene level, enabling identification of meaningful relative differences in sample count data.

```{r ind_plot}
plotCounts(deseq.analysis, gene = 'ENSMUSG00000020649', intgroup = 'isolate')
```

## Clustering

Clustering of data features or samples from the counts matrix is a standard method of analysis prior to differential gene expression. It provides information on the similarities between the data groups, such as if the samples group as expected given different variable status, or if features group in a manner that reveals potential similarities in genetic function or pathway.

An alternative _DESeqDataSet_ object can be created using the _vst_ method. This is a data transformation method that reduces the effect of the mean counts of genes on the level of variance in counts of genes across the whole experiment. It is not used in differential gene expression, but is useful for clustering methods as it makes the data more homoskedastic.

Example variance-stabilised _DESeqDataSet_:

```{r vst}
vst.matrix <- varianceStabilizingTransformation(deseq.analysis)
head(vst.matrix)
```

Using the transformed data, principal component analysis can be conducted. The aim of this method is to reduce the many related variables down to a few unrelated variables, and determine the effect of these on gene count variance across the experiment. Typically the two principal components with the strongest effects are plotted in a PCA plot to show grouping within the explanatory variables.

```{r pca}
pca.df <- vst.matrix %>% assay() %>% t() %>% prcomp()
pca.plot <- plotPCA(vst.matrix, intgroup = c('isolate')) + theme_classic()
pca.plot
```

Another form of typical clustering analysis is a denogram representing heirarchical clustering of samples by overall gene counts pattern, and this can be combined with a heatmap showing the correlation of each sample to every other sample by the same pattern.

```{r heatmap}
correlation.matrix <- vst.matrix %>% assay() %>% cor()
pheatmap(correlation.matrix, annotation_col = coldata)
```


## _DESeq_ function checks

DESeq2 filters the overall counts matrix to remove genes with low counts from the analysis to prevent excessive penalisng in multiple testing correction due to genes with limited information. The threshold for classifying low counts is determined by seeking the cut-off which would provide the greatest number of significant hits after multiple testing correction, and varies across each comparison. This threshold can be accessed and modified. The plot below shows the number of genes excluded from the analysis resulting from a filter threshold set at a given quantile _theta_, and the vertical line showing the final _theta_ cutoff used.

```{r filt}
ggplot(metadata(deseq.results)$filterNumRej, aes(theta, numRej)) +
  geom_point() +
  geom_vline(xintercept = metadata(deseq.results)$filterTheta) +
  theme_classic()
```

The _DESeq_ function utilises the calculated dispersion metric dataset-wide in order to estimate more accurate variance levels in each individual gene's counts. It is key that these dispersion values fit with the pattern expected across the dataset, such as lower dispersion levels at greater mean normalised counts, and most genes showing similar levels of dispersion at a given number of mean normalised counts. They overall distribution pattern of the data should follow the fitted line of expected levels of dispersion regardless of any model variable, and the dispersion levels of most genes should be shrunk towards this line, towards a more likely true level of gene dispersion. If the dispersion data does not fit this pattern, the normalised count data may not follow the expected variance patterns and the subsequent gene expression differences tested may not be valid.

```{r disp_est}
plotDispEsts(deseq.analysis)
```

## Differential gene expression results checks

One of the quality checks to use to determine if the differential gene expression results fit the pattern expected from the statistical analysis is to plot the p-value distributions. The histograms should show a flat, even distribution across p-values, with the exception of a large peak at the very lowest p-values indicating the presence of true differences based on the contrast provided. Histogram patterns that deviate from this expectation are a sign that something is wrong with the analysis.

```{r pval_hist}
hist(deseq.results$pvalue[deseq.results$baseMean > 1], xlab = 'p-value', main = 'histogram of p-values')
```

An MA plot is another check, to identify the variability of fold change levels across genes with different count levels. The genes are coloured if significantly different in the expression analysis, and these coloured points should occur with lower fold changes as mean counts increases. Genes with the very lowest counts should typically not be coloured regardless of fold change, as there is not enough data for these from which to draw reliable conclusions.  

```{r ma}
plotMA(deseq.results)
```


&nbsp;
&nbsp;

#### Volcano plot

Volcano plot showing distribution of differential gene expression by signficance level and fold change magnitude. Gene datapoints differentiated by colour for strong changes (pvalue < 0.05, fold change > |1.5|), slight changes (pvalue < 0.05, fold change <= |1.5|), no significant change (pvalue > 0.05). The cutoffs are for adjusted pvalue (Benjamini Hochberg method), and for regular fold change of |1.5|.

```{r volcano, warning=FALSE}
gfill <- c('Strongly up' = 'red', 'Slightly up' = 'pink', 
          'Strongly down' = 'blue', 'Slightly down' = 'lightblue', 
          'None' = 'grey')
gsize <- c('Strongly up' = 2, 'Slightly up' = 2, 
          'Strongly down' = 2, 'Slightly down' = 2, 
          'None' = 1)


plotVolcano <- function(res){
  as.data.frame(res) %>%
    filter(!is.na(padj)) %>%
    mutate(change = ifelse(padj < 0.05, 
                           ifelse(log2FoldChange > 0, 
                                  ifelse(log2FoldChange > log2(1.5), 'Strongly up', 'Slightly up'), 
                                  ifelse(log2FoldChange < -log2(1.5), 'Strongly down', 'Slightly down')), 
                           'None')) %>%
  ggplot(aes(log2FoldChange, -log10(pvalue))) + 
    geom_point(aes(fill = change, size = change), shape = 21, alpha = 0.5) +
    scale_fill_manual(values = gfill) +
    scale_size_manual(values = gsize) +
    geom_hline(yintercept = -log10(0.00265), linetype = 'dashed', alpha = 0.5) +
    geom_vline(xintercept = log2(1.5), linetype = 'dashed', alpha = 0.5) +
    geom_vline(xintercept = -log2(1.5), linetype = 'dashed', alpha = 0.5) +
    theme_classic()
}

plotVolcano(deseq.results)
```

Output files:
Full differential gene expression results tables written to .csv file 