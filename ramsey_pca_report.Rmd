---
title: "S303 PCA analysis"
author: "Prasanth Sivakumar"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
    toc_depth: 4
    toc_collapsed: FALSE
    toc_float: FALSE
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir = normalizePath('C:/Users/Prasanth/Documents/ramsey/')) 
```

### Quick summary \
PCA suggests that in each of the three comparisons of 'Control' samples vs 'CLL LN', 'CLL PB', and 'Reactive LN' treated samples, the treated samples cluster away from the controls. This is true for PC1, the component which explains the greatest differences between all samples, and the correlation between PC1 value and sample group (treatment) status is high. The results suggest that treatment condition could be the primary driver of differences between gene counts across all genes. 

### Analysis

This report illustrates the results of the PCA for the S303 dataset across 3 comparisons: 

* Control v CLL LN 
* Control v CLL PB 
* Control v Reactive 

In this report, the results for each stage of the analysis are shown concurrently for each analysis for easy comparison. The dataset results are labelled as: 

* 'Control v CLL LN' = 'ctrl_v_cll_ln' 
* 'Control v CLL PB' = 'ctrl_v_cll_pb'
* 'Control v Reactive' = 'ctrl_v_reac'

```{r libs, message=FALSE, warning=FALSE}
library(PCAtools)
library(DESeq2)
library(tidyverse)
library(vsn)
```

```{r load_cms}
# load count matrices
load('ramsey_s303_norm_counts_matrix.RData')
load('ramsey_s303_non_zero_counts_matrix.RData')
```

```{r load_md}
# load metadata
md <- read.csv('s303_metadata.csv')
```

```{r modify_md}
# add matrix sample names to metadata variable as different
#md$matrix_id <- stringr::str_sort(colnames(zcm), numeric = T)
# wrong length because NAT 4 is in metadata but not matrix
md <- md[md$sample_id != 'NAT 4', ]
# works after removing
md$matrix_id <- stringr::str_sort(colnames(zcm), numeric = T)
# check to make sure
#View(md[, c('sample_id', 'matrix_id')])

# re-sort whole md to match matrix variable order
md <- arrange(md, factor(matrix_id, levels = colnames(zcm)))
# convert matrix ids to row names
md <- column_to_rownames(md, 'matrix_id')

# edit md 'reactive lymph nodes' to shorten
md$sample_group <- gsub('Lymph Nodes\n$', 'LN', md$sample_group)
md$sample_group <- gsub('\n$', '', md$sample_group)
```

&nbsp;
&nbsp;

#### Metadata

Here is a table of the sample metadata provided for this analysis. Not all variables were utilised in the analysis

```{r study_specific}
# in this analysis, only the 'NAT' samples are going to be used, 
# so both the md and cm will be subsetted for these
smpls <- colnames(zcm)[grep('NAT', colnames(zcm))]
nat.cm <- zcm[, smpls]
nat.md <- md[smpls, ]

# sample groups
smpl.grps <- list(cll_ln = rownames(nat.md[nat.md$sample_group == 'CLL LN', ]), 
                  cll_pb = rownames(nat.md[nat.md$sample_group == 'CLL PB', ]), 
                  ctrl = rownames(nat.md[nat.md$sample_group == 'Control', ]), 
                  reac = rownames(nat.md[nat.md$sample_group == 'Reactive LN', ]))

# subset metadata by comparisons
mds <- list(ctrl_v_cll_ln = md[c(smpl.grps$ctrl, smpl.grps$cll_ln), ], 
            ctrl_v_cll_pb = md[c(smpl.grps$ctrl, smpl.grps$cll_pb), ], 
            ctrl_v_reac = md[c(smpl.grps$ctrl, smpl.grps$reac), ])

mds$ctrl_v_cll_ln$sample_group <- factor(mds$ctrl_v_cll_ln$sample_group, levels = c('Control', 'CLL LN'))
mds$ctrl_v_cll_pb$sample_group <- factor(mds$ctrl_v_cll_pb$sample_group, levels = c('Control', 'CLL PB'))
mds$ctrl_v_reac$sample_group <- factor(mds$ctrl_v_reac$sample_group, levels = c('Control', 'Reactive LN'))

print(nat.md)
#lapply(mds, dim)
```

&nbsp;
&nbsp;

#### Input count matrices

Here are the dimensions of each input counts matrix for each analysis: rows (genes) x columns (samples)

```{r zcms}
# cms subset by sample group comparisons
zcms <- list(ctrl_v_cll_ln = zcm[, c(smpl.grps$ctrl, smpl.grps$cll_ln)], 
             ctrl_v_cll_pb = zcm[, c(smpl.grps$ctrl, smpl.grps$cll_pb)], 
             ctrl_v_reac = zcm[, c(smpl.grps$ctrl, smpl.grps$reac)])

# cms filtered for low counts specifically in comparison subset
zcms <- lapply(zcms, function(mat) mat[rowSums(mat) > (((dim(mat)[2])/2)-1), ])
lapply(zcms, dim)
```

```{r ncms}
# normalised subset cms
ncms <- list(ctrl_v_cll_ln = ncm[, c(smpl.grps$ctrl, smpl.grps$cll_ln)], 
             ctrl_v_cll_pb = ncm[, c(smpl.grps$ctrl, smpl.grps$cll_pb)], 
             ctrl_v_reac = ncm[, c(smpl.grps$ctrl, smpl.grps$reac)])
```

&nbsp;
&nbsp;

#### Outliers

Here is an outline of potential outlier counts in genes for every sample. If 'NULL', there are no outlier counts across the whole matrix. Outlier here is defined as a value 3 standard deviations away from the mean count for that gene across the samples. 

In these analyses, the 'Control v CLL LN' and 'Control v Reactive' subsets had no genes with outlier counts in any samples. In the 'Control v CLL PB' analysis, there were 101 genes with outlier counts in any one sample. This is a small proportion of the 20,000+ genes included in the analysis. The majority of genes (59) had the outlier count in the 'NAT 16' sample. For now, this sample hasn't been excluded, it has been retained in further analysis. 

```{r outliers, message=FALSE}
# outlier check
outlierCheck <- function(mat){
  g <- list()
  s <- list()
  for (i in 1:(dim(mat)[1])){
    mean.i <- mean(mat[i, ])
    sd.i <- sd(mat[i, ])
    for (j in mat[i, ]){
      if (j > (mean.i + (3*sd.i)) & sd.i > 1){
        g <- append(g, row.names(mat)[i])
        s <- append(s, colnames(mat)[which(mat[i, ] == j)])
      } else if (j < (mean.i - (3*sd.i)) & sd.i > 1){
        g <- append(g, row.names(mat)[i])
        s <- append(s, colnames(mat)[which(mat[i, ] == j)])
      }
    }
  }
  o <- data.frame('sample' = unlist(s), 'gene' = unlist(g))
  return(o)
}

outliers <- lapply(ncms, outlierCheck)
```

```{r outplt}
plotOutliers <- function(outlier){
  df <- as.data.frame(table(outlier$sample))
  if (nrow(df) != 0){ 
    ggplot(df, aes(Var1, Freq)) + 
      geom_col(fill = 'lightsalmon3') +
      labs(x = 'Sample', y = 'Outlier Gene Count') + 
      theme_classic() +
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
  }
}

outliers.plots <- lapply(outliers, plotOutliers)
outliers.plots
```

```{r vst}
# stabilise variance across data to make it homoskedastic
svcms <- lapply(zcms, varianceStabilizingTransformation)
# similar to scale(log2(ncms$ctrl_v_reac + 1), center = T, scale = T)
```


```{r sd}
#The counts matrix is normalised to produce approximately homoskedastic counts across genes. 
#The standard deviation is still slightly higher in genes with high counts, but the effect is substantially dampened.
# check variance transformation adequate
#sdPlots <- lapply(svcms, meanSdPlot)
```


```{r bps}
#Boxplot of log2 gene counts across samples after normalisation
# plot ranges of log counts per sample for matrix subsets
#lapply(svcms, function(m) boxplot(log2(m)))
```


```{r sample_vs}
#Scatter of counts per gene across two samples
# compare total vst counts between two samples
#plot(x = svcms[[1]][, 1], y = svcms[[1]][, 2])
```


```{r run_pcas, message=FALSE}
# run pca, remove bottom 10% of variables based on variance
pcas <- list()
for (name in names(svcms)){
  p <- pca(svcms[[name]], metadata = mds[[name]], removeVar = 0.1)
  p <- list(p)
  names(p) <- name
  pcas <- append(pcas, p)
}
```

&nbsp;
&nbsp;

#### PCA
##### How few components can the variation in samples be reduced to?

Principal component analysis is unsupervised, the results do not factor in the sample group to which each sample has been labelled. \n

The analysis produces 'components'. Each component can be used to explain a % of the total variation across the samples counts. Scree plots show the results of this. Principal component 1 explains the most variation. Also marked is the principal component at which cumulatively 80% of the variation in the dataset can be explained. 

* In 'Control v CLL LN' 42% of the variation between all samples in the dataset can be explain in one component, suggesting a large proportion of the variation can be 


```{r screes, warning=FALSE}
# plot the components eigenvalues as % variance explanation
optimumScree <- function(pca, svcm, ttl){
  comp <- which(cumsum(pca$variance) > 80)[1]
  plt <- screeplot(pca,
            components = getComponents(pca, 1:8),
            vline = comp, axisLabSize = 8, 
            title = ttl, gridlines.major = F, gridlines.minor = F, 
            borderWidth = 0.5, xlabAngle = 45, colBar = 'lightsalmon3') +
    geom_label(aes(x = comp, y = 10,
                   label = '80% explained', vjust = -3, hjust = 1, size = 8)) 
  return(plt)
}

optimumScree(pcas$ctrl_v_cll_ln, svcms$ctrl_v_cll_ln, 'Control v CLL LN')
optimumScree(pcas$ctrl_v_cll_pb, svcms$ctrl_v_cll_pb, 'Control v CLL PB')
optimumScree(pcas$ctrl_v_reac, svcms$ctrl_v_reac, 'Control v Reactive')
```

Here are the classic PCA plots showing differences between each sample, labelled by sample group. Each sample group is also highlighted. \

* In 'Control v CLL LN' the samples can be clustered by group. Samples are spread concordant with their group in PC1, which explains a substantial amount of the variation, suggesting that the sample being either 'Control' or 'CLL LN' may be a primary driver of the difference in gene counts.  

* In 'Control v CLL PB' again sample group difference could be a primary driver of PC1 spread, although not to the same level. The previously mentioned outlier counts in 'NAT 16' are likely to be what is causing that sample to cluster far away from all other 'CLL PB' samples, and all samples overall. 

* In 'Control v Reactive', again sample group could explain differences in PC1 value. 'Reactive' samples are spread out, and highlight another potential outlier in 'NAT 7'.

```{r bi_sample, message=FALSE}
# biplot of all samples by PC1 vs PC2, with clouds
bi.plt.smpls <- 
  lapply(pcas, function(p) biplot(p, showLoadings = F, colby = 'sample_group', 
                                  encircle = T, widthConnectors = 0.1, 
                                  gridlines.minor = F,  gridlines.major = F,
                                  legendPosition = 'right', legendLabSize = 8,
                                  legendTitleSize = 8, legendIconSize = 4,
                                  axisLabSize = 8, borderWidth = 0.5, xlim = c(-25, 25)))
bi.plt.smpls
```


```{r bi_load}
# add gene labels with biggest effects
#PCA plot which includes largest loadings - the genes most influential for the PCA results
#bi.plt.load <- 
#  lapply(pcas, function(p) biplot(p, showLoadings = T, sizeLoadingsNames = 3, lab = NULL, colby = 'sample_group', 
#                                  widthConnectors = 0.1, gridlines.minor = F, gridlines.major = F, 
#                                  legendPosition = 'right', legendLabSize = 8, legendTitleSize = 8, legendIconSize = 4, 
#                                  axisLabSize = 10))
#bi.plt.load
```

Overview of principal component comparisons across the first 4 components. for each analysis. In each grid, each principal component in compared to every other principal component from PC1-PC4. This can be useful to see if the samples segregate by sample group in components smaller than PC1 and PC2.

* 'Control v CLL LN' Samples only split by group in PC1, not PC2, PC3, or PC4. 
* 'Control v CLL PB' Samples split by group in PC1, and slightly in PC2 discounting the potential outlier. 
* 'Control v Reactive' Samples split by group in PC1 only. 


```{r paired}
# comparison scatters for PC1-4 on grid
pairs.plt <- 
  lapply(pcas, function(p) pairsplot(p, components = getComponents(p, 1:4),
                                     triangle = F, colby = 'sample_group',
                                     axisLabSize = 8, 
                                     margingaps = unit(c(0.2, 0.2, 0.2, 0.2), 'cm'), 
                                     borderWidth = 0.5))
pairs.plt
```

The sample-based principal component information outlined above can be seen in table format. In this table, the value of each sample in each principal component is displayed. This again outlines the anomalous values of 'NAT 16' in PC1 of the 'Control v CLL PB' analysis, and to a certain extent 'NAT 7' in PC1 of the 'Control v Reactive' analysis.

```{r rotated}  
# sample contribution to each PC
rotateds <- lapply(pcas, `[[`, 'rotated') %>% lapply(`[`, 1:4)
rotateds
```


Plot of loadings for each principal component. Each gene in the matrix has a different level of influence on the variation in the principal component as a whole. Genes with the largest component loading (here in absolute values) can be thought of as the genes driving the differences in the component. 

```{r loadings, message=FALSE}
# plot individual contribution of genes with largest loadings
loadings.plt <- 
  lapply(pcas, function(p) plotloadings(p, components = getComponents(p, 1:4), rangeRetain = 0.001, 
                                        shapeSizeRange = c(2, 10), absolute = T, legendPosition = 'none', 
                                        #legendLabSize = 8, legendIconSize = 4, 
                                        axisLabSize = 8, gridlines.major = F, gridlines.minor = F, hline = NULL, 
                                        borderWidth = 0.5, labSize = 2, labhjust = 0.9, 
                                        col = c('white', 'lightsalmon3')))
loadings.plt
```


Correlation table for each principal component by RNA-quality variables provided in the metadata. For each analysis, 'sample_group' shows the clearest strong correlation with PC1. In the 'Control v CLL PB' analysis, the r2 value is significant to p < 0.01. 

```{r eigcor2, warning=FALSE}
# get pearson r2 values and significane of correlation of PCs with metadata variables
# unnamed columns
eigencorr2.plt <-
  lapply(pcas, function(p) eigencorplot(p, getComponents(p, 1:4),
                                        metavars = c('sample_group', "rin_2", 
                                                     "a260_280_ndrop"), 
                                        colCorval = 'white', posColKey = 'top', 
                                        plotRsquared = T, corFUN = 'pearson', corUSE = 'pairwise.complete.obs', 
                                        col = c('navajowhite2', 'indianred1', 'indianred2', 'firebrick1'), corMultipleTestCorrection = 'BH'))
eigencorr2.plt
```


```{r loads}
#The relative influence of most influential genes on principal component values
#can also be seen in table form below. 

# each gene contribution to each PC
#loads <- lapply(pcas, `[[`, 'loadings')
# as.data.frame(loads$ctrl_v_reac) %>% arrange(desc(abs(PC1)))
```


```{r opt, warning=FALSE}
# Scree plots as before, but annotated with values. Horn's and Elbow methods are #methods by which the 'optimum' principal component cut off is decided based on #differing calculations. Also marked is the component at which cumulatively 80% #of the variation can be explained by the principal components

# calculate 'optimum' number of PCs to use via horn and elbow methods, plot scree
# also how many components for 80%
# optimumScree <- function(pca, svcm){
#   horn <- parallelPCA(svcm)
#   elbow <- findElbowPoint(pca$variance)
#   comp <- which(cumsum(pca$variance) > 80)[1]
#   plt <- screeplot(pca,
#             components = getComponents(pca, 1:8),
#             vline = c(comp, horn$n, elbow), 
#             axisLabSize = 8) +
#     geom_label(aes(x = horn$n, y = 50,
#                    label = 'Horn\'s', vjust = -3, size = 8)) +
#     geom_label(aes(x = elbow, y = 50,
#                    label = 'Elbow method', vjust = -3, size = 8))  +
#     geom_label(aes(x = comp, y = 50,
#                    label = '80% explained', vjust = -3, size = 8)) 
#   return(plt)
# }
# 
# optimumScree(pcas$ctrl_v_cll_ln, svcms$ctrl_v_cll_ln)
# optimumScree(pcas$ctrl_v_cll_pb, svcms$ctrl_v_cll_pb)
# optimumScree(pcas$ctrl_v_reac, svcms$ctrl_v_reac)
# number of components that need to be included to explain X% variance
#ncomponents <- lapply(pcas, function(p) which(cumsum(p$variance) > 80)[1])
```
