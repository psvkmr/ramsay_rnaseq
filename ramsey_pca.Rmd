---
title: "S303 PCA analysis"
author: "Prasanth Sivakumar"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath('C:/Users/Prasanth/Documents/ramsey/')) 
```

```{r libs, message=FALSE, warning=FALSE}
library(PCAtools)
library(DESeq2)
library(tidyverse)
library(vsn)
```

```{r load_cms}
# load count matrices
load('ramsey_s303_norm_counts_matrix.RData')
load('ramsey_s303_non_zero_counts_matrix.RData')
```

```{r load_md}
# load metadata
md <- read.csv('s303_metadata.csv')
```

```{r modify_md}
# add matrix sample names to metadata variable as different
#md$matrix_id <- stringr::str_sort(colnames(zcm), numeric = T)
# wrong length because NAT 4 is in metadata but not matrix
md <- md[md$sample_id != 'NAT 4', ]
# works after removing
md$matrix_id <- stringr::str_sort(colnames(zcm), numeric = T)
# check to make sure
#View(md[, c('sample_id', 'matrix_id')])

# re-sort whole md to match matrix variable order
md <- arrange(md, factor(matrix_id, levels = colnames(zcm)))
# convert matrix ids to row names
md <- column_to_rownames(md, 'matrix_id')

# edit md 'reactive lymph nodes' to shorten
md$sample_group <- gsub('Lymph Nodes\n$', 'LN', md$sample_group)
```

Here is the data frame of metadata for all samples to be included in this analysis

```{r study_specific}
# in this analysis, only the 'NAT' samples are going to be used, 
# so both the md and cm will be subsetted for these
smpls <- colnames(zcm)[grep('NAT', colnames(zcm))]
nat.cm <- zcm[, smpls]
nat.md <- md[smpls, ]

# sample groups
smpl.grps <- list(cll_ln = rownames(nat.md[nat.md$sample_group == 'CLL LN\n', ]), 
                  cll_pb = rownames(nat.md[nat.md$sample_group == 'CLL PB\n', ]), 
                  ctrl = rownames(nat.md[nat.md$sample_group == 'Control\n', ]), 
                  reac = rownames(nat.md[nat.md$sample_group == 'Reactive LN', ]))

# subset metadata by comparisons
mds <- list(ctrl_v_cll_ln = md[c(smpl.grps$ctrl, smpl.grps$cll_ln), ], 
            ctrl_v_cll_pb = md[c(smpl.grps$ctrl, smpl.grps$cll_pb), ], 
            ctrl_v_reac = md[c(smpl.grps$ctrl, smpl.grps$reac), ])

print(nat.md)
#lapply(mds, dim)
```

```{r zcms}
# cms subset by sample group comparisons
zcms <- list(ctrl_v_cll_ln = zcm[, c(smpl.grps$ctrl, smpl.grps$cll_ln)], 
             ctrl_v_cll_pb = zcm[, c(smpl.grps$ctrl, smpl.grps$cll_pb)], 
             ctrl_v_reac = zcm[, c(smpl.grps$ctrl, smpl.grps$reac)])

# cms filtered for low counts specifically in comparison subset
zcms <- lapply(zcms, function(mat) mat[rowSums(mat) > (((dim(mat)[2])/2)-1), ])
```

Here are the dimensions of each input counts matrix for each analysis: rows (genes) x columns (samples)

```{r ncms}
# normalised subset cms
ncms <- list(ctrl_v_cll_ln = ncm[, c(smpl.grps$ctrl, smpl.grps$cll_ln)], 
             ctrl_v_cll_pb = ncm[, c(smpl.grps$ctrl, smpl.grps$cll_pb)], 
             ctrl_v_reac = ncm[, c(smpl.grps$ctrl, smpl.grps$reac)])
lapply(ncms, dim)
```

Here is an outline of potential outlier counts in genes for every sample. If 'NULL', there are no outlier counts across the whole matrix. If outliers are present, a bar chart is plotted showing the number of genes with outlier counts for each sample. Outlier here is defined as a value 3 standard deviations away from the mean count for that gene across the samples. 

```{r outliers}
# outlier check
outlierCheck <- function(mat){
  g <- list()
  s <- list()
  for (i in 1:(dim(mat)[1])){
    mean.i <- mean(mat[i, ])
    sd.i <- sd(mat[i, ])
    for (j in mat[i, ]){
      if (j > (mean.i + (3*sd.i)) & sd.i > 1){
        g <- append(g, row.names(mat)[i])
        s <- append(s, colnames(mat)[which(mat[i, ] == j)])
      } else if (j < (mean.i - (3*sd.i)) & sd.i > 1){
        g <- append(g, row.names(mat)[i])
        s <- append(s, colnames(mat)[which(mat[i, ] == j)])
      }
    }
  }
  o <- data.frame('sample' = unlist(s), 'gene' = unlist(g))
  return(o)
}

outliers <- lapply(ncms, outlierCheck)

plotOutliers <- function(outlier){
  df <- as.data.frame(table(outlier$sample))
  if (nrow(df) != 0){ 
    ggplot(df, aes(Var1, Freq)) + 
      geom_col() +
      labs(x = 'Sample', y = 'Count') + 
      theme_classic() +
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
  }
}

outliers.plots <- lapply(outliers, plotOutliers)
outliers.plots
```

```{r vst}
# stabilise variance across data to make it homoskedastic
svcms <- lapply(zcms, varianceStabilizingTransformation)
# similar to scale(log2(ncms$ctrl_v_reac + 1), center = T, scale = T)
```

The counts matrix is normalised to produce approximately homoskedastic counts across genes. 
The standard deviation is still slightly higher in genes with high counts, but the effect is substantially dampened.

```{r sd}
# check variance transformation adequate
sdPlots <- lapply(svcms, meanSdPlot)
```

Boxplot of log2 gene counts across samples after normalisation

```{r bps}
# plot ranges of log counts per sample for matrix subsets
lapply(svcms, function(m) boxplot(log2(m)))

```

Scatter of counts per gene across two samples

```{r sample_vs}
# compare total vst counts between two samples
plot(x = svcms[[1]][, 1], y = svcms[[1]][, 2])
```

Scree plots showing the results of the PCA as eigenvalues for each principal component 

```{r run_pcas}
# run pca, remove bottom 10% of variables based on variance
pcas <- list()
for (name in names(svcms)){
  p <- pca(svcms[[name]], metadata = mds[[name]], removeVar = 0.1)
  p <- list(p)
  names(p) <- name
  pcas <- append(pcas, p)
}
```

```{r screes}
# plot the components eigenvalues as % variance explanation
screes <- lapply(pcas, function(p) screeplot(p, getComponents(p, 1:8)))
screes
```

Classic PCA plot showing differences between each sample, labelled by sample group

```{r bi_sample}
# biplot of all samples by PC1 vs PC2, with clouds
bi.plt.smpls <- 
  lapply(pcas, function(p) biplot(p, showLoadings = F, colby = 'sample_group', encircle = T,
                                  widthConnectors = 0.1, gridlines.minor = F,  gridlines.major = F,
                                  legendPosition = 'right', legendLabSize = 8, legendTitleSize = 8, 
                                  legendIconSize = 4, axisLabSize = 8))
bi.plt.smpls
```

PCA plot which includes largest loadings - the genes most influential for the PCA results

```{r bi_load}
# add gene labels with biggest effects
bi.plt.load <- 
  lapply(pcas, function(p) biplot(p, showLoadings = T, sizeLoadingsNames = 3, lab = NULL, colby = 'sample_group', 
                                  widthConnectors = 0.1, gridlines.minor = F, gridlines.major = F, 
                                  legendPosition = 'right', legendLabSize = 8, legendTitleSize = 8, legendIconSize = 4, 
                                  axisLabSize = 10))
bi.plt.load
```

Overview of principal component comparisons across the first 4 components. Even if segregation by variable of interest is not seen in comparisons of PC1 vs PC2, it could be identified here in PC3 or PC4

```{r paired}
# comparison scatters for PC1-4 on grid
pairs.plt <- 
  lapply(pcas, function(p) pairsplot(p, components = getComponents(p, 1:4), triangle = F, 
                                     colby = 'sample_group', axisLabSize = 8))
pairs.plt
```

Plot of loadings for each principal component, showing the top 0.1% of most influential genes. Absolute values. 

```{r loadings}
# plot individual contribution of genes with largest loadings
loadings.plt <- 
  lapply(pcas, function(p) plotloadings(p, components = getComponents(p, 1:4), rangeRetain = 0.001, 
                                        shapeSizeRange = c(2, 10), absolute = T, legendPosition = 'none', 
                                        #legendLabSize = 8, legendIconSize = 4, 
                                        axisLabSize = 8, gridlines.major = F, gridlines.minor = F))
loadings.plt
```

Correlation table for each principal component by each valid variable used in the metadata. Scale is strength of correlation. Variables marked by * denote levels of significance. 

```{r eicor}
# plot loadings of each variable for each component
# unnamed columns
eigencor.plt <- 
  lapply(pcas, function(p) eigencorplot(p, getComponents(p, 1:5),
                                        metavars = c("sample_group", "rin_2", "rna_conc_qubit", "rna_dil_conc_qubit", "total_rna_qubit",
                                                     "rna_conc_ndrop", "total_rna_ndrop", "a260_280_ndrop", "a260_230_ndrop"), 
                                        col = c('darkblue', 'blue2', 'black', 'red2', 'darkred'), 
                                        colCorval = 'white', posColKey = 'top'))
eigencor.plt
```

Correlation table for each principal component by each valid variable used in the metadata. Scale is strength of correlation. Variables marked by * denote levels of significance. 

```{r eigcor2}
# get pearson r2 values and significane of correlation of PCs with metadata variables
# unnamed columns
eigencorr2.plt <-
  lapply(pcas, function(p) eigencorplot(p, getComponents(p, 1:5),
                                        metavars = c('sample_group', "rin_2", "rna_conc_qubit", "rna_dil_conc_qubit", "total_rna_qubit",
                                                     "rna_conc_ndrop", "total_rna_ndrop", "a260_280_ndrop", "a260_230_ndrop"), 
                                        colCorval = 'white', posColKey = 'top', 
                                        plotRsquared = T, corFUN = 'pearson', corUSE = 'pairwise.complete.obs', 
                                        corMultipleTestCorrection = 'BH'))
eigencorr2.plt
```

Relative influence of each sample on principal component values

```{r rotated}  
# sample contribution to each PC
rotateds <- lapply(pcas, `[[`, 'rotated')
rotateds
```

Relative influence of most influential genes on principal component values

```{r loads}
# each gene contribution to each PC
loads <- lapply(pcas, `[[`, 'loadings')
# as.data.frame(loads$ctrl_v_reac) %>% arrange(desc(abs(PC1)))
```

Scree plots as before, but annotated with values. Horn's and Elbow methods are methods by which the 'optimum' principal component cut off is decided based on differing calculations. Also marked is the component at which cumulatively 80% of the variation can be explained by the principal components

```{r opt, warning=FALSE}
# calculate 'optimum' number of PCs to use via horn and elbow methods, plot scree
# also how many components for 80%
optimumScree <- function(pca, svcm){
  horn <- parallelPCA(svcm)
  elbow <- findElbowPoint(pca$variance)
  comp <- which(cumsum(pca$variance) > 80)[1]
  plt <- screeplot(pca,
            components = getComponents(pca, 1:8),
            vline = c(comp, horn$n, elbow), 
            axisLabSize = 8) +
    geom_label(aes(x = horn$n, y = 50,
                   label = 'Horn\'s', vjust = -3, size = 8)) +
    geom_label(aes(x = elbow, y = 50,
                   label = 'Elbow method', vjust = -3, size = 8))  +
    geom_label(aes(x = comp, y = 50,
                   label = '80% explained', vjust = -3, size = 8)) 
  return(plt)
}

optimumScree(pcas$ctrl_v_cll_ln, svcms$ctrl_v_cll_ln)
optimumScree(pcas$ctrl_v_cll_pb, svcms$ctrl_v_cll_pb)
optimumScree(pcas$ctrl_v_reac, svcms$ctrl_v_reac)
# number of components that need to be included to explain X% variance
#ncomponents <- lapply(pcas, function(p) which(cumsum(p$variance) > 80)[1])
```
